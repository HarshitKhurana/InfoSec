
<h3>Stack Canary</h3>
<hr>
<b> Ques : What is a Stack Canary ? </b> 
</br>
<b> Ans &nbsp; </b> A Stack Canary also known as a <b>stack gaurd</b> is a small integer, the value of which is randomly chosen at program start and placed in the executable binary to ensure that no buffer overflow happened.
</br> &emsp; -> The executable generated by the compiler consist of code for generating and checking the stack canary.</br>
</br>
<b> Ques : How does it work ? </b> </br>
<b> Ans &nbsp; </b>: The way it works is that a small integer value which is randomly chosen at program start and placed in the memory just before the stack return pointer. Most buffer overflows overwrite memory from lower to higher memory addresses, so in order to overwrite the return pointer (and thus take control of the process) the canary value must also be overwritten. This value is checked to make sure it has not changed before a routine uses the return pointer on the stack.</br>
&emsp; -> Prologue</br>
&emsp; &emsp; -> push an additional value into the stack (canary)</br>
&emsp; -> Epilogue</br>
&emsp; &emsp; -> pop the canary value from the stack and check that it hasn’t changed</br>

</br>
</br>
<b> [*] Canary Types</br> </b>
</br>
<ul>
<li type=1><b> Random Canary – </b>The original concept for canary values took  32-bit pseudorandom value generated by the /dev/random or /dev/urandom devices on a Linux operating system.</li>
<li type=1><b> Random XOR Canary – </b>The random canary concept was extended in StackGuard version 2 to provide slightly more protection by performing a XOR operation on the random canary value with the stored control data.</li>
<li type=1><b> Null Canary – </b>In this the canary value is set to 0x00000000 which is chosen based upon the fact that most string functions terminate on a null value and should not be able to overwrite the return address if the buffer must contain nulls before it can reach the saved address.</li>
<li type=1><b> Terminator Canary – </b>The canary value is set to a combination of Null, CR, LF, and 0xFF. These values act as string terminators in most string functions, and accounts for functions which do not simply terminate on nulls such as gets().</li>
</ul>
</br>
<b> [*] How to disable Stack Canary</br> </b>
&emsp; -> By default no stack canary is added by gcc compiler(depends on gcc version + OS too) but it can be added by using appropriate flag while code compilation.
</br>
&emsp; Example : On a 32-bit Linux machine

```bash
root@PC-Name:~$ cat stackCanary.c
#include<stdio.h>

int main( int argc,  char *argv[]){
  printf ("Stack Canary program\n");
}

# Stack Canary disabled 
root@PC-Name:~$ gcc stackCanary.c -o noCanary -fno-stack-protector
root@PC-Name:~$ gdb noCanary
Dump of assembler code for function main:
   0x0804841d <+0>: push   ebp
   0x0804841e <+1>: mov    ebp,esp
   0x08048420 <+3>: and    esp,0xfffffff0
   0x08048423 <+6>: sub    esp,0x10
   0x08048426 <+9>: mov    DWORD PTR [esp],0x80484d0
   0x0804842d <+16>:  call   0x80482f0 <puts@plt>
   0x08048432 <+21>:  leave  
   0x08048433 <+22>:  ret    
End of assembler dump.

# Compiling with Stack Canary 
root@PC-Name:~$ gcc stackCanary.c -fstack-protector-all -o yesCanary
root@PC-Name:~$ gdb yesCanary
Dump of assembler code for function main:
   0x0804846d <+0>: push   ebp
   0x0804846e <+1>: mov    ebp,esp
   0x08048470 <+3>: and    esp,0xfffffff0
   0x08048473 <+6>: sub    esp,0x20
   0x08048476 <+9>: mov    eax,DWORD PTR [ebp+0x8]
   0x08048479 <+12>:  mov    DWORD PTR [esp+0xc],eax
   0x0804847d <+16>:  mov    eax,DWORD PTR [ebp+0xc]
   0x08048480 <+19>:  mov    DWORD PTR [esp+0x8],eax
   0x08048484 <+23>:  mov    eax,gs:0x14    # Copying canary from gs:0x14 memory location into EAX
   0x0804848a <+29>:  mov    DWORD PTR [esp+0x1c],eax
   0x0804848e <+33>:  xor    eax,eax
   0x08048490 <+35>:  mov    DWORD PTR [esp],0x8048540
   0x08048497 <+42>:  call   0x8048340 <puts@plt>
   0x0804849c <+47>:  mov    edx,DWORD PTR [esp+0x1c]
   0x080484a0 <+51>:  xor    edx,DWORD PTR gs:0x14    # Stack canary checking 
   0x080484a7 <+58>:  je     0x80484ae <main+65>
   0x080484a9 <+60>:  call   0x8048330 <__stack_chk_fail@plt>   # If check fail return stack check failed.
   0x080484ae <+65>:  leave  
   0x080484af <+66>:  ret    
End of assembler dump.

```

</br>
</br>
<b> [*] ByPassing Stack Canaries</br> </b>
</br>
<ul>
 <li type="0"> If you understood it correctly(or look at assembly again) you would know that it is easy to bypass stack canary check if you can somehow fethc the value of stack canary(called Canary Leaking), i.e then you can overflow the buffer and in the end re-write that value to the appropriate register and the `XOR` will return `true`.</li>
<li type="0"> Get shell before stack canary check is done.</li>
<li type="0"> Function’s arguments control , Returning with an altered frame pointer , More control over local variables , Pointing caller’s frame to GOT</li>
 <li type="0"> <a href="https://www.secureauth.com/files/private/publications/2016/05/StackguardPaper.pdf"> WhitePaper</a></li>
</ul>

</br>
</br>
</br>
<b> [*] NOTE: </br> </b>
</br>&emsp; -> Stack canary only prevent from `overflow` attacks and cannot do anything regarding the `underflow` attacks.
</br>&emsp; -> <a href="https://ctf101.org/binary-exploitation/stack-canaries/" target="_blank">Bypassing Stack Canary </a>
</br>&emsp; -> <a href="https://uaf.io/exploitation/2015/09/29/Stack-CANARY-Overwrite-Primer.html" target="_blank">Over-writing Stack Canary </a>
</br>&emsp; -> <a href="https://www.kapravelos.com/teaching/csc591-f17/lectures/03-canaries.pdf" target="_blank">Stack Canary and defense</a>
</br>
